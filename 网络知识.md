---
layout: post
title: 网络知识点总结归纳
date: 2020-05-08 23:05:08
updated: 2020-06-09 14:59:12
tags: 
  - Web基础
  - 前端框架
  - 知识回顾
categories: 前端知识

---

> 本文主要对Web基础和前端框架知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。

<!-- more -->

<div style='display: none'>

<!-- TOC -->

- [Web基础](#web基础)
    - [1. 常用的网络传输协议](#1-常用的网络传输协议)
    - [2. ARP协议](#2-arp协议)
    - [3. TCP与UDP的区别](#3-tcp与udp的区别)
    - [4. 常见的状态码](#4-常见的状态码)
    - [5. 三次握手](#5-三次握手)
    - [6. 四次挥手](#6-四次挥手)
    - [7. 为什么连接的时候是三次握手，关闭的时候却是四次握手](#7-为什么连接的时候是三次握手关闭的时候却是四次握手)
    - [8. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态](#8-为什么time_wait状态需要经过2msl最大报文段生存时间才能返回到close状态)
    - [9. 如果已经建立了连接，但是客户端突然出现故障了怎么办](#9-如果已经建立了连接但是客户端突然出现故障了怎么办)
    - [10. session和cookie的区别](#10-session和cookie的区别)
    - [11. https的建立连接的过程](#11-https的建立连接的过程)
    - [12. https的传输数据是否是对称加密](#12-https的传输数据是否是对称加密)
    - [13. TCP拥堵控制](#13-tcp拥堵控制)
    - [14. 如何高效处理socket](#14-如何高效处理socket)
    - [15. http的组成](#15-http的组成)
    - [16. http的头部，keepalive的作用](#16-http的头部keepalive的作用)
    - [17. tcp建立连接的方式](#17-tcp建立连接的方式)
    - [18. 本机的socket需要经过协议栈解包么](#18-本机的socket需要经过协议栈解包么)
    - [19. socket编程](#19-socket编程)
    - [20. urllib和urllib2](#20-urllib和urllib2)
    - [21. 常见的web安全问题有哪些](#21-常见的web安全问题有哪些)
    - [22. POST和GET的区别](#22-post和get的区别)
    - [23. python中实现IO多路复用](#23-python中实现io多路复用)
    - [24. select,poll和epoll](#24-selectpoll和epoll)
    - [25. python常用的并发网络库](#25-python常用的并发网络库)
    - [26. 什么是前后端分离，优缺点各是什么](#26-什么是前后端分离优缺点各是什么)
    - [27. nginx与apache的区别](#27-nginx与apache的区别)
- [Django](#django)
- [Flask](#flask)
- [Tornado](#tornado)
- [jQuery](#jquery)
- [Vue](#vue)
- [AngularJS](#angularjs)
- [React](#react)

<!-- /TOC -->

</div>

# Web基础

## 1. 常用的网络传输协议

- TCP：传输控制协议，可靠传输，面向连接
- UDP：用户数据包协议，不可靠传输，面向无连接
- FTP：文件传输协议,用于上传和下载文件
- HTTP：超文本传输协议，基于TCP/IP通信协议，面向对象
- SMTP：邮件传输协议
- TELNET：Internet远程登录服务的标准协议和主要方式
- DNS：域名系统，将域名解析为ip地址

## 2. ARP协议

> ARP（Address Resolution Protocal）地址解析协议，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6已经不再适用，并被邻居发现协议（NDP）所替代。

## 3. TCP与UDP的区别

- TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；UDP提供无连接的传输，通信前不需要建立连接。
- TCP提供可靠的传输（有序、无差错、不丢失、不重复）；UDP提供不可靠的传输。
- TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销。
- TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和流量控制。

> 应用场景：

- 对数据可靠性的要求高的应用需要选择TCP协议，如验证密码；而对数据可靠性要求不那么高的可以选择UDP协议。
- 对应用实时性要求高的因公可以选择UDP协议，如视频监控等。
- 在网络状况不好的情况下需选用TCP协议，如广域网；而网络状况很好的情况下就不需要采用TCP协议，建议选择UDP协议来减少网络负荷，如局域网。

## 4. 常见的状态码

| 状态码 | 状态 | 描述 |
| :----: | :---- | :---- |
| 200 | Ok | 请求成功 |
| 400 | Bad Request | 请求语法错误，不能被服务器解析 |
| 401 | Unauthorized | 未经授权，需与www-Authenticate一起用 |
| 403 | Forbidden | 服务器收到请求，但拒绝提供服务 |
| 404 | Not Found | 请求资源不存在 |
| 500 | Internal Server Error | 服务器发生不可预期的错误 |
| 503 | Server Unavailable | 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 |

> 总之，HTTP状态码分为5个类别：

- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

## 5. 三次握手

- 第一次握手：建立连接时，客户端发送SYN包（SYN=1,seq=x）到服务器，并进入同步已发送状态（SYN_SENT），等待服务器确认。状态过程：`SYN=1, seq=x`。
- 第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=x+1）,同时自己也发送一个SYN包（seq=y），即SYN+ACK包（SYN=1,ACK=1），服务器进入同步收到状态（SYN_RECV）。状态过程：`SYN=1, ACK=1, seq=y, ack=x+1`。
- 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认ACK包（ack=y+1），此包发送完毕，客户端和服务器进入已建立连接状态（ESTAB_LISHED），完成握手。状态过程：`ACK=1, seq=x+1, ack=y+1`。

## 6. 四次挥手

- 第一次挥手：客户端进程发出连接释放报文，并停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（实际上等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入终止等待1状态（FIN_WAIT_1）。TCP规定，FIN报文段即使不携带数据也要消耗洗个序号。状态过程：`FIN=1, seq=u`。
- 第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时服务端就进入等待关闭状态（CLOSE-WAIT）。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端依然要接受。客户端收到服务器的确认请求后，此时客户端就进入了终止等待状态2（FIN-WAIT-2），接受服务器发送的最后的数据并等待服务器发送连接释放报文。状态过程：`ACK=1, seq=v, ack=u+1`。
- 第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能有发送了一些数据，假定此时的序列号为seq=w，此时服务器就就进入了最后确认状态（LAST-ACK），等待客户端确认。状态过程：`FIN=1, ACK=1, seq=w, ack=u+1`。
- 第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时客户端就进入了时间等待状态（TIME-WAIT）。此时TCP连接还没有释放，必须经过最长报文段寿命（2MSL）的时间后，当客户端撤销相应的TCB后，服务器就接收到客户端发出的确认，才进入CLOSED状态。状态过程：`ACK=1, seq=u+1, ack=w+1`。

## 7. 为什么连接的时候是三次握手，关闭的时候却是四次握手

> 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

## 8. 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态

> 按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

## 9. 如果已经建立了连接，但是客户端突然出现故障了怎么办

> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## 10. session和cookie的区别

> Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端会把Cookie保存起来。

> Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录，以便再次访问时确认身份。每个用户访问服务器都会建立一个session，用户与服务器建立连接的同时，服务器会自动为其分配一个SessionId。

> session和cookie的区别：

- cookie数据存放在客户的浏览器上，session数据放在服务器上
- cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session
- session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie
- 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
- 可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中

> 应用场景：

- 登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是cookie
- session一个场景是购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了session

## 11. https的建立连接的过程

## 12. https的传输数据是否是对称加密

## 13. TCP拥堵控制

## 14. 如何高效处理socket

## 15. http的组成

## 16. http的头部，keepalive的作用

## 17. tcp建立连接的方式

## 18. 本机的socket需要经过协议栈解包么

## 19. socket编程

## 20. urllib和urllib2

> urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。

> urllib2可以接受一个Request对象来为URL请求设置headers(请求头)，urllib仅可以接受URL，不能伪装用户代理User Agent字符串等。

## 21. 常见的web安全问题有哪些

- SQL注入
- CSRF（跨站请求伪造）
- XSS（跨站脚本攻击）

## 22. POST和GET的区别

- GET主要是读取资源，POST主要是改写/新建资源
- 不可以重复的操作， 比如创建一个条目/修改一条记录， 用POST, 因为POST不能被缓存，所以浏览器不会多次提交。
- 可以重复的交互，比如取个数据，跳个页面， 用GET。
- GET请求的URL可以手动输入，请求的URL可以存在书签里，或者历史里，且URL可以被搜索引擎收录。
- GET是幂等的、只读的、纯粹的操作，而POST是非幂等的操作。

## 23. python中实现IO多路复用

## 24. select,poll和epoll

## 25. python常用的并发网络库

- tornado
- gevent
- asyncio

## 26. 什么是前后端分离，优缺点各是什么

> 后端只负责提供数据接口，不在渲染模版，前端从接口获取数据并呈现

> 优点：

- 实现前后端解耦，接口复用，减少开发量
- 前后端各司其职，同步开发，提升开发效率
- 有利于调试、测试与运维部署
- 有利于快速定位问题，前端问题前端解决，接口数据问题后端解决
- 大并发的情况下，可以同时水平扩展前后端服务器
- 减少后端服务器的并发/负载压力，前端http请求在nginx上，后台接口请求调用tomcat
- 即使后端服务器暂时超时或者宕机了，前端页面也会正常访问，只不过数据显示不出来而已

> 缺点：

- 不利于页面SEO优化
- 前端工作量加大

## 27. nginx与apache的区别

> nginx相对apache的优点：

- 轻量级，起同样的web服务，比apache占用更少的内存及资源
- 抗并发，nginx处理请求是异步阻塞的，支持更多的并发连接，而apache则是阻塞型的，在高并发下nginx能保持低资源低消耗但高性能
- 配置简洁
- 高度模块化的设计，编写模块相对简单
- 社区活跃

> apache相对nginx的优点：

- rewrite，比nginx的rewrite更强大
- 模块超多，支持很多
- 比nginx的bug少很多
- 很稳定

# Django

# Flask

# Tornado

# jQuery

# Vue

# AngularJS

# React