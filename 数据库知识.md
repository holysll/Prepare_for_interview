---
layout: post
title: 数据库知识点总结归纳
date: 2020-05-08 23:05:08
updated: 2020-05-14 01:45:02
tags: 
  - 数据库
  - Mysql
  - Redis
categories: 数据库

---

> 本文主要对数据库基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。

<!-- more -->

<div style='display: none'>

<!-- TOC -->

- [数据库常识](#数据库常识)
    - [1. 什么是索引](#1-什么是索引)
    - [2. 索引的数据结构](#2-索引的数据结构)
    - [3. 什么是聚簇索引](#3-什么是聚簇索引)
    - [4. 建立索引需要考虑的因素](#4-建立索引需要考虑的因素)
    - [5. 联合索引](#5-联合索引)
    - [6. 查看索引是否被使用到](#6-查看索引是否被使用到)
    - [7. 什么是事务](#7-什么是事务)
    - [8. 事务的特性](#8-事务的特性)
    - [9. MySql的事务隔离级别](#9-mysql的事务隔离级别)
    - [10. 同时多个事务并发执行可能造成的问题](#10-同时多个事务并发执行可能造成的问题)
    - [11. 不可重复读和幻读的区别](#11-不可重复读和幻读的区别)
    - [12. 共享锁与排他锁](#12-共享锁与排他锁)
    - [13. 表级锁、行级锁、页级锁](#13-表级锁行级锁页级锁)
    - [14. 死锁](#14-死锁)
    - [15. 什么是悲观锁](#15-什么是悲观锁)
    - [16.什么是乐观锁](#16什么是乐观锁)
    - [17. MySQL支持哪些存储引擎](#17-mysql支持哪些存储引擎)
        - [(1) InnoDB存储引擎](#1-innodb存储引擎)
        - [(2) MyISAM存储引擎](#2-myisam存储引擎)
        - [(3) MEMORY存储引擎](#3-memory存储引擎)
        - [(4) MERGE存储引擎](#4-merge存储引擎)
        - [(5) Archive存储引擎](#5-archive存储引擎)
        - [(6) EXAMPLE存储引擎](#6-example存储引擎)
        - [(7) NDB Cluster存储引擎](#7-ndb-cluster存储引擎)
        - [(8) FEDERATED存储引擎](#8-federated存储引擎)
        - [(9) CSV存储引擎](#9-csv存储引擎)
        - [(10) BLACKHOLE存储引擎](#10-blackhole存储引擎)
    - [为什么要尽量设定一个主键](#为什么要尽量设定一个主键)
    - [主键使用自增ID还是UUID](#主键使用自增id还是uuid)
    - [字段为什么要求定义为NOT NULL](#字段为什么要求定义为not-null)
    - [如果要存储用户的密码散列，应该使用什么字段进行存储](#如果要存储用户的密码散列应该使用什么字段进行存储)
    - [存储过程](#存储过程)
    - [数据库怎么优化查询效率](#数据库怎么优化查询效率)
    - [数据库优化方案](#数据库优化方案)
    - [什么是缓存穿透](#什么是缓存穿透)
    - [什么是缓存击穿](#什么是缓存击穿)
    - [什么是缓存雪崩](#什么是缓存雪崩)
    - [如何分库分表](#如何分库分表)
    - [多个索引会有多份数据么](#多个索引会有多份数据么)
    - [如何防止是数据库单点问题](#如何防止是数据库单点问题)
    - [如何确保多台机器不会重复消费](#如何确保多台机器不会重复消费)
    - [如何确保消费了反馈失效问题](#如何确保消费了反馈失效问题)
    - [. SQL查询基础](#-sql查询基础)
    - [. 排序](#-排序)
    - [. 聚合函数](#-聚合函数)
    - [. 分组](#-分组)
    - [. 关联查询](#-关联查询)
    - [. LIMIT的用法](#-limit的用法)
    - [. case when](#-case-when)
- [Mysql数据库](#mysql数据库)
    - [1. mysql 常用数据类型](#1-mysql-常用数据类型)
    - [2. mysql数据库引擎](#2-mysql数据库引擎)
    - [3. mysql的索引类型](#3-mysql的索引类型)
    - [4. mysql 几种锁的区别](#4-mysql-几种锁的区别)
    - [5. mysql事务原理、特性、事务并发控制](#5-mysql事务原理特性事务并发控制)
    - [6. mysql里的in、not in、like走不走索引](#6-mysql里的innot-inlike走不走索引)
    - [7. mysql查询优化](#7-mysql查询优化)
    - [8. mysql的主从复制](#8-mysql的主从复制)
    - [9.左连接右连接的区别](#9左连接右连接的区别)
- [Redis数据库](#redis数据库)
    - [1. redis的原理](#1-redis的原理)
    - [2. 持久化机制](#2-持久化机制)
    - [3. redis 和 memcached 的主要区别](#3-redis-和-memcached-的主要区别)
    - [4. Redis 高可用](#4-redis-高可用)
    - [5. Redis 高并发](#5-redis-高并发)
    - [6. redis的数据类型](#6-redis的数据类型)
    - [7. redis的AOF太大如何优化](#7-redis的aof太大如何优化)
    - [8. redis集群，如何扩展](#8-redis集群如何扩展)
- [MongoDB数据库](#mongodb数据库)
    - [1. 如何启动](#1-如何启动)
- [Elasticsearch数据库](#elasticsearch数据库)
    - [1. 索引如何存储](#1-索引如何存储)
    - [2. 介绍下Elastisearch原理和用途](#2-介绍下elastisearch原理和用途)
    - [3. 分布式实时日志使用ELK](#3-分布式实时日志使用elk)
- [Hive数据库](#hive数据库)
- [Hbase数据库](#hbase数据库)
- [Hadoop生态](#hadoop生态)

<!-- /TOC -->

</div>

# 数据库常识

## 1. 什么是索引

> 索引其实就是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候,索引可以大大的加快查询的速度，这是因为使用索引之后不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据的屋里地址然后访问相应的数据。

> 索引的缺点：在创建索引和维护索引会耗费时间，随着数据的增加而增加.索引也会增加，所以如果是经常增删改的列创建索引会大大的增加项目的维护速度。

> 索引的分类：

- 普通索引
- 主键索引
- 唯一索引
- 组合索引

> 创建索引和删除索引：

```python
# 普通索引
create index [index_name] on [tb_name](字段名)
alter table [tb_name] add index [index_name](字段名)

drop index [index_name] on [tb_name]  # 删除索引

# 主键索引
alter table [tb_name] add primary key(字段名)

# 删除主键索引：
alter table [tb_name] drop primary key  # 普通非自增主键

alter table [tb_name] id modify id int;  # 自增主键，取消自增列
alter table [tb_name] drop primary key  # 删除主键索引

# 唯一索引，与普通索引类似，可以有null值
create unique index [index_name] on tb_name(字段名)
alter table [tb_name] add unique index [index_name](字段名)

drop index [index_name] on [tb_name]  # 删除索引

# 组合索引

```

## 2. 索引的数据结构

> 索引的数据结构和具体存储引擎的实现有关，在MySql中常用的有Hash索引和B+树索引，而常用的`InnoDB`存储引擎的默认索引实现为：B+树索引。

- Hash索引

> Hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获取实际数据。

- B+树索引

> B+树索引底层实现是多路平衡查找树，所有节点遵循左节点小于父节点，右节点大于父节点；对于每一次查询都是从根节点出发，查找到叶子节点方可以获取所查询的键值，然后根据查询判断是否需要返回表查询数据。

> Hash索引与B+树所以的差异：

- hash索引进行等值查询比较快，但是无法进行范围查询，而B+支持范围查询；
- hash索引不支持使用索引排序；
- hash索引不支持模糊查询以及多列索引的最左前缀匹配；
- hash索引避免不了回表查询数据，而B+树在（聚簇索引、覆盖索引）的时候可以只通过索引完成查询；
- hash索引不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率极差，而B+树查询效率比较稳定，所有查询都是从根节点到叶子节点，且树的高度较低。

## 3. 什么是聚簇索引

> 在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在`InnoDB`中，只有主键索引才是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引；如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

> 当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用在进行回表查询。

> 非聚簇索引也不一定会回表查询，因为这涉及到查询语句所要求的字段是否全部命中了索引，如果是，那么就不用再进行回表查询了。

## 4. 建立索引需要考虑的因素

- 考虑字段的使用频率，经常作为条件进行查询的字段；
- 经常作为表连接的字段考虑建索引；
- 经常在order by、group by之后的字段考虑建索引；
- 考虑联合索引中的顺序，否则无法命中索引
- 对非空字段(NOT NULL)创建索引，Mysql很难对控制做查询优化
- 索引适合区分度高、离散程度大的字段，有大量重复值的字段不适合建索引；
- 索引的长度不能太长，耗时

## 5. 联合索引

> MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

> 因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

## 6. 查看索引是否被使用到

> MySQL提供了explain命令来查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，如`possilbe_key, key,key_len`等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。

> Mysql索引未被使用到的情况：

- 列参与了数学运算或者函数；
- 在字符串like时，左边是通配符，如'%aaa';
- 当Mysql分析全表扫描比使用索引快的时候不用索引；
- 当使用联合索引，前面一个条件为范围查询，后面的即使符合最左前缀原则，也无法使用索引；

## 7. 什么是事务

> 在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务；事务是数据库并发控制的基本单位；事务可以用来管理INSERT/UPDATE/DELETE操作语句；事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行（回滚）。

## 8. 事务的特性

- 原子性(Atomicity)

> 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。

- 一致性(Consistency)

> 几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。

- 隔离性(Isolation)

> 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。

- 持久性(Durability)

> 对于任意已交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现异常。

## 9. MySql的事务隔离级别

- 读未提交（Read uncommitted）

> 事物A和事物B，事物A未提交的数据，事物B可以读取到"脏数据"；隔离级别低，一般都高于该级别。

- 读已提交（Read committed）

> 事物A和事物B，事物A提交的数据，事物B才能读取到;隔离级别高于读未提交，可以避免脏读，但是可能会导致不可重复读和幻读。（是Oracle默认隔离级别）

- 可重复读（Repeatable read）

> 事务A和事务B，事务A提交之后的数据，事务B是可重复读取数据这时事务B读取不到；该隔离级别高于读已提交，可以避免不可重复读，但有可能导致幻读，MySQL（也是InnoDB）默认隔离级别。

- 串行化（Serializable）

> 事务A和事务B，事务A在操作数据库时，事务B只能排队等待；这种隔离级别很少使用，吞吐量太低，用户体验差，这种级别可以避免脏读、重复读、幻读，每一次读取的都是数据库中真实存在数据，这时事务A与事务B串行，而不是并发。

**[四个隔离级别可能出现脏读、不可重复读、幻读问题](https://blog.csdn.net/JIESA/article/details/51317164)**

|  隔离级别 |    |  出现情况  |    |
|  :----:  |  :----:  |  :----:  |  :----:  |
|    |  脏读  |  不可重复读  |  幻读  |
|  读未提交  |  √  |  √  |  √  |
|  读已提交  |  ×  |  √  |  √  |
|  可重复读  |  ×  |  ×  |  √  |
|  串行化  |  ×  |  ×  |  ×  |

## 10. 同时多个事务并发执行可能造成的问题

- 脏读：就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问这个数据，然后使用了这个数据。
- 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。
- 幻读：事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。
- 丢失修改：并发写入造成其中一些修改丢失。

## 11. 不可重复读和幻读的区别

- 不可重复读是读取了其他事务更改的数据，针对update操作

> 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

- 幻读是读取了其他事务新增的数据，针对insert与delete操作

> 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。

## 12. 共享锁与排他锁

> 共享锁(shared lock)，又叫读锁，读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，而不会造成阻塞。当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。

```sql
SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
```

> 排他锁(exclusive lock)，又叫写锁，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，它和其他的排他锁、共享锁都相斥。

```sql
SELECT * FROM table_name WHERE ... FOR UPDATE
```

## 13. 表级锁、行级锁、页级锁

**[MySQL锁详解](https://www.cnblogs.com/luyucheng/p/6297752.html)**

> 表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。

- 使用表级锁的主要是MyISAM、MEMORY、CSV等一些非事务性存储引擎。

> 行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。
虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。

- 使用行级锁的主要是InnoDB存储引擎。

> 页级锁是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。

- 使用页级锁的主要是BerkeleyDB存储引擎。

**MySQL中这三种锁的总结**

> 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

> 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

> 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

> 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。

## 14. 死锁

> 在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。

> 在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。当InnoDB检测到系统中产生了死锁之后，InnoDB会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。实际上在InnoDB发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。

> 避免死锁的常用方法：

- 在应用中，如果不同的程序会并发存储多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的概率。
- 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。
- 在事务中，如果要更新记录，应该直接申请足够级别的锁，及排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得相同记录的共享锁，从而造成锁冲突，甚至死锁。
- 在可重复读隔离级别下，如果两个线程同时对相同条件记录用`select ... for update`加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么，就会出现死锁。这种情况下，将隔离级别该为读已提交，就可以避免问题。
- 当隔离级别为读已提交时，如果两个线程都先执行`select ... for update`，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现等待，当第一个线程提交后，第二个线程会因主键重复出错，但虽然这个线程出错了，却获得一个排他锁。这时，如果有第三个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后在捕获主键异常，或在遇到主键重错误时，总是执行Rollback释放获得的排他锁。

## 15. 什么是悲观锁

> 悲观锁(Pessimistic Lock)，顾名思义就是很悲观。每次去操作数据的时候，都会认为别人会修改。所以为了防止别人修改，就在操作的时候上锁。这样别人来访问的时候就会阻塞在那里直到锁被是释放。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。

> 遵循逻辑为一锁二查三更新(select for update)会把数据给锁住，其中MySQL默认InnoDB引擎，默认是行级锁，基于索引的，若SQL语句用不到索引，则不会使用行级锁的，会使用表级锁将整张表锁住。

```python
# 来源：https://www.jianshu.com/p/083bbe5f5534
# encoding:utf-8
"""
场景：商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单的时候必须确保该商品status为1。假设商品id为1。
"""

# 如果不使用锁,那么操作方法如下:
# 1.查询出商品信息
select status from t_goods where id = 1;

# 2.根据商品信息生成订单
insert into t_orders(id,goods_d) values(null,1);
# 3.修改商品status为2
update t_goods set status=2;

"""
上面这种场景在高并发访问的情况下很可能会出现问题。
前面已经提到，只有上status为1的时候，才能对该商品下单，上面的第一步操作中查询出来的上面品status为1，但是当我们执行第二步的时候，很有可能有的人先一步执行了步骤2和步骤3，此时订单已经被下过了，然后我们又下了一次。很有可能就出现一个订单被下单了两次的情况。
"""

# 解决这种问题的方法，我们使用悲观锁来实现。
"""
在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程。使用悲观锁的原理就是,当我们查询goods的信息时，就把当前的数据锁住，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。

注意：如果要使用悲观锁，我们必须将mysql数据库的自动提交功能关闭。因为mysql默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySql会立即将结果进行提交。
"""

# 我们可以使用命令设置MySQL为非autocommit的模式:
set autocommit=0;
# 设置完autocommit后,我们就可以执行我们的正常业务了。具体如下：

# 0.事务开始
begin;/begin work;/start trasaction;  # 三者选一即可
# 1.查询出商品信息
select status from t_goods where id=1 for update;
# 2.根据商品信息生成订单
insert into t_orders (id ,goods_id) values (null,1);
# 3.修改商品status为2
update t_goods set status=2;
# 4.提交事务
commit;/ commint work;

# 上面的第一步我们执行了一次查询操作:
select status from t_goods from t_good where id=1 for update;

# 与普通查询不一样的是，我们使用了select... for update的方式，这样就通过数据库实现了悲观锁。此时t_goods表中，id为1的那条数据就被我们锁定了，其他的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其他事务修改。
```

> 悲观锁的优缺点：悲观锁的策略是先取锁在访问，保证了数据的安全性，但是效率方面，处理锁机制会让数据库产生额外开销，还有可能增加产生死锁的可能，所以一般只有在写操作冲突很多的时候才使用悲观锁，而读操作不需要加锁。

## 16.什么是乐观锁

> 乐观锁(Optimistic Lock)，顾名思义就是很乐观，每次去拿数据的时候都认为比人不会修改，所以不会上锁。但是在更新数据的时候，会判断一下在更新数据的这段时间内，数据有没有被修改；如果被修改了，就取消这次操作；如果没有被修改，则使得这次操作生效。一般使用版本号或者时间戳的方式来实现。

> 遵循先修改，更新时发现数据已经变了就回滚(check and set)，乐观锁一般通过数据库版本号或时间戳实现。在数据库增加一个字段version，当我们操作数据的时候，将版本号一同取出来，当我们更新数据，在提交更新的时候，会再去数据查询下当前的版本号，跟我们之前取出来的版本号，是否一致。如果一致，就使得这次更新生效。并且在每次更新数据的时候，都使得版本号加1。

```python
"""
使用版本号时,可以再数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断一下当前的版本号是不是该数据的最新的版本号。
"""
# 1. 查询出商品信息
select (status, version) from t_goods where id = 'id';

# 2.根据商品信息生成订单

# 3.修改商品status为2
update t_goods set status=2, version=version+1
where id='id' and version='version';
```

> 乐观锁的优缺点：乐观并发控制相信事务之间的数据竞争的概率是比较小的，会先进行操作。再提交的时候，再进行验证这次提交是否可行，因此不会有任何的死锁和锁。但是这样做还是有问题的，例如如果某两个事务对同一行的数据同时进行了修改，经过修改之后，同时写进了数据库，这时就会出现问题。所以乐观锁，一般用在读数据比较多的地方。而对于写数据比较多的地方，我们最好使用悲观锁来解决。

## 17. MySQL支持哪些存储引擎

**[MySQL的存储引擎的特点比较](https://blog.csdn.net/holysll/article/details/89197810)**

### (1) InnoDB存储引擎

> MySQL的默认存储引擎，提供事务安全表，该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。用于事务处理应用程序，具有众多特性，包括ACID事务支持。相对于MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。

> InnoDB主要特点：

- InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎；
- InnoDB有强大的CPU效率，能够处理巨大数据量；
- InnoDB存储引擎完全与MySQL服务器整合，将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件，表可以是任何尺寸；
- InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。

### (2) MyISAM存储引擎

> MyISAM存储引擎是管理非事务表，不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表，支持3种不同的存储格式，分别是：静态表（字段长度固定）、动态表（字段长度动态不固定）、压缩表（每个记录单独被压缩，访问开支小）。默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。

> MyISAM的主要特点：

- 大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持；
- 当把删除和更新及插入操作混合使用的时候，动态大小的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成；
- 每个MyISAM表最大索引数是64，这可以通过重新编译来改变，每个索引最大的列数是16；
- NULL被允许在索引的列中，这个值占每个键的0~1个字节；
- 可以把数据文件和索引文件放在不同目录；

### (3) MEMORY存储引擎

> Memory存储引擎使用存在于内存中的内容来创建表。每个Memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果。

### (4) MERGE存储引擎

> Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，Merge表本身并没有数据，对Merge类型的表可以进行select、update、delete操作，这些操作实际上是对内部的MyISAM表进行的。允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。

### (5) Archive存储引擎

> 存储引擎被用来无索引的、非常小的覆盖存储大量数据。为大量很少引用的历史、归档、或安全审计信息的存储和检索提供了完美的解决方案。

### (6) EXAMPLE存储引擎

> EXAMPLE存储引擎是一个“存根”引擎，可以用这个引擎创建表，但没有数据被存储于其中或从其中检索，这个引擎的目的是服务，可为快速创建定制的插件式存储引擎提供帮助。

### (7) NDB Cluster存储引擎

> MySQL的簇式数据库引擎，是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎，尤其适合于具有高性能查找要求的应用程序，这类查找需求还要求具有最高的正常工作时间和可用性。

### (8) FEDERATED存储引擎

> FEDERATED存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。能够将多个分离的MySQL服务器链接起来，从多个物理服务器创建一个逻辑数据库。十分适合于分布式环境或数据集市环境。

### (9) CSV存储引擎

> CSV存储引擎把数据以逗号分隔的格式存储在文本文件中。

### (10) BLACKHOLE存储引擎

> BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集。用于临时禁止对数据库的应用程序输入。

## 为什么要尽量设定一个主键

> 主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。

## 主键使用自增ID还是UUID

> 推荐使用自增ID，不要使用UUID（通用唯一识别码，Universally Unique Identifier）。因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说主键索引的B+树叶子节点上存储了主键索引以及全部的数据，如果主键索引是自增ID,那么只需要不断向后排序即可；如果用UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入、数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。

## 字段为什么要求定义为NOT NULL

```mysql
# MySQL官网这样介绍：
NULL columns require additional space in the rowto record whether their values are NULL. For MyISAM tables, each NULL columntakes one bit extra, rounded up to the nearest byte.
```

> NULL值会占用更多的字节，且会在程序中造成很多与预期不符的情况。

## 如果要存储用户的密码散列，应该使用什么字段进行存储

> 密码散列、盐、用户身份证号等固定长度的字符串应该使用`char`而不是`varchar`来存储,这样可以节省空间且提高检索效率.

## 存储过程

## 数据库怎么优化查询效率

## 数据库优化方案

## 什么是缓存穿透

## 什么是缓存击穿

## 什么是缓存雪崩

## 如何分库分表

## 多个索引会有多份数据么

## 如何防止是数据库单点问题

## 如何确保多台机器不会重复消费

## 如何确保消费了反馈失效问题

## . SQL查询基础

**[SQL基础知识](https://www.runoob.com/sql/sql-tutorial.html)**

- select语句

> 格式：select 字段 from 表名； # 全部字段可以用 *

- where 用于限制查询的结果

> 格式：where 字段='xxx';  # 查询条件> < >= <= = !=

- 与(AND)或(OR)

- 在(IN)不在(NOT IN)

- 空(NULL)非空(NOT NULL)

- 全部(ALL) 任一(ANY)

- 在[a,b]之间

> 格式：between a and b

- 排重DISTINCT

> 格式：select DISTINCT 字段 from 表名；

## . 排序

- ORDER BY语句

> 格式：select 字段 from 表名 where 条件 ORDER BY 字段；

- 升序(ASC)与降序(DESC)

> 格式：select 字段 from 表名 where 条件 ORDER BY 字段 ASC;  
> 格式：select 字段 from 表名 where 条件 ORDER BY 字段 DESC;  

- 多项排序

> 格式：select 字段 from 表名 where 条件 ORDER BY 字段 ASC|DESC，字段ASC|DESC;

## . 聚合函数

> 把 select 语句的查询结果汇聚成一个结果，这样的函数叫聚合函数。

- 最大值(MAX)

- 最小值(MIN)

- 平均值(SVG)

- 求和(SUM)

- 统计数量(COUNT)

## . 分组

- GROUP BY

> 格式：select 组函数 from 表 where 条件 group by 字段;

- HAVING 组判断条件，它的真假决定一组数据是否返回

> 格式：select 组函数 from 表 where 条件 group by 字段 having 组判断条件;

## . 关联查询

- JOIN：如果表中有至少一个匹配，则返回行  

> 格式：select * from a join b on a.id=b.id;

- 内连接(INNER JOIN)：只返回两个表中联结字段相等的行

> 格式：select * from a inner join b on a.id=b.id;  # 其中inner可以省略，等同于JOIN的用法

- 左外连接(LEFT JOIN 或 LEFT OUTER JOIN)：即使右表中没有匹配，也从左表返回所有的行

> 格式：select * from a left outer join b on a.id=b.aid;  # 其中outer可忽略

- 右外连接(RIGHT JOIN 或 RIGHT OUTER JOIN)：即使左表中没有匹配，也从右表返回所有的行

> 格式：select * from a right outer join b on a.id=b.aid;  # 其中outer可忽略

- 全连接(FULL JOIN 或 FULL OUTER JOIN): 只要其中一个表中存在匹配，就返回行。相当于左外连接+右外链接，注意mysql不支持全连接

> 格式：select * from a full outer join b on a.id=b.id。# 其中outer可忽略

- 自连接：自连接意思是把自身表当成另外一张表看待，互相关联查询，连接方式可以使用以上的内外连接，这种连接方式可以解决很多奇怪的问题。

> 格式：SELECT ab.* from a ab,a ac where ab.id>ac.id

## . LIMIT的用法

> 格式：select * from student limit 10;  # 查询前10条数据，显示1-10条数据

> 格式：select * from student limit 1,10;  # 查询从第2行开始，累加10条id记录，共显示id为2....11

> 格式：select * from student limit 5,10;  # 查询从第6行开始向前加10条数据，共显示id为6,7....15  

> 格式：select * from student limit i,n;  # i: 为查询结果的索引值(默认从0开始),当i=0时可省略i; n: 为查询结果返回的数量

## . case when

**[CASE WHEN 及 SELECT CASE WHEN的用法](https://www.cnblogs.com/aipan/p/7770611.html)**
**[SQL Case when 的使用方法](https://www.cnblogs.com/cx-zyq/archive/2013/05/16/3082295.html)**

- 简单Case函数

```sql
CASE sex
WHEN '1' THEN '男'
WHEN '2' THEN '女'
ELSE '其他' END
```

- Case搜索函数

```sql
CASE WHEN sex = '1' THEN '男'
WHEN sex = '2' THEN '女'
ELSE '其他' END
```
> 两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。还有一个需要注意的问题，Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。

**实例分析：**

(1). 已知数据按照另外一种方式进行分组，分析

```sql
/*根据这个国家人口数据，统计亚洲和北美洲的人口数量*/
SELECT  SUM(population),
CASE country  WHEN '中国' THEN '亚洲'
  WHEN '印度' THEN '亚洲'
  WHEN '日本' THEN '亚洲'
  WHEN '美国' THEN '北美洲'
  WHEN '加拿大'  THEN '北美洲'
  WHEN '墨西哥'  THEN '北美洲'
ELSE '其他' END
FROM    Table_A
GROUP BY
CASE country 
WHEN '中国' THEN '亚洲'
WHEN '印度' THEN '亚洲'
WHEN '日本' THEN '亚洲'
WHEN '美国' THEN '北美洲'
WHEN '加拿大'   THEN '北美洲'
WHEN '墨西哥'   THEN '北美洲'
ELSE '其他' END;

```

```sql
/*判断工资的等级，并统计每一等级的人数*/
SELECT
CASE WHEN salary <= 500 THEN '1'
WHEN salary > 500 AND salary <= 600  THEN '2'
WHEN salary > 600 AND salary <= 800  THEN '3'
WHEN salary > 800 AND salary <= 1000 THEN '4'
ELSE NULL END salary_class, -- 别名命名
COUNT(*)  FROM    Table_A
GROUP BY
CASE WHEN salary <= 500 THEN '1'
WHEN salary > 500 AND salary <= 600  THEN '2'
WHEN salary > 600 AND salary <= 800  THEN '3'
WHEN salary > 800 AND salary <= 1000 THEN '4'
ELSE NULL END;
```

(2). 用一个SQL语句完成不同条件的分组

```sql
/*按照国家和性别进行分组*/
SELECT country, 
SUM( CASE WHEN sex = '1' THEN  population ELSE 0 END),  --男性人口
SUM( CASE WHEN sex = '2' THEN  population ELSE 0 END)   --女性人口
FROM  Table_A  GROUP BY country;
```

(3). 在Check中使用Case函数

```sql
/*公司A，这个公司有个规定，女职员的工资必须高于1000块*/
CONSTRAINT check_salary CHECK
( CASE WHEN sex = '2'
THEN CASE WHEN salary > 1000
THEN 1 ELSE 0 END
ELSE 1 END = 1 )
```

(4). 根据条件有选择的UPDATE

```sql
/* 1.工资5000以上的职员，工资减少10% */
UPDATE Personnel  SET salary = salary * 0.9  WHERE salary >= 5000;

/* 2.工资在2000到4600之间的职员，工资增加15% */
UPDATE Personnel  SET salary = salary * 1.15 WHERE salary >= 2000 AND salary < 4600;

/* 3.如果满足条件1和条件2，顺序执行则会出现问题。
假设有个人工资5000块。首先，按照条件1，工资减少10%，变成工资4500。
接下来运行第二个SQL时候，因为这个人的工资是4500在2000到4600的范围之内，需增加15%，
最后这个人的工资结果是5175,不但没有减少，反而增加了。
如果要是反过来执行，那么工资4600的人相反会变成减少工资。 
这里用到case when 进行不同条件的更新*/
UPDATE Personnel
SET salary =
CASE WHEN salary >= 5000  　                THEN salary * 0.9
     WHEN salary >= 2000 AND salary < 4600  THEN salary * 1.15
ELSE salary END;  -- 这行else必须写，不写会导致不符合这两个条件的工资会变成NULL
```

```sql
/* 把主键a和b相互交换 */
UPDATE SomeTable
SET p_key = CASE WHEN p_key = 'a'  THEN 'b'
WHEN p_key = 'b'  THEN 'a'  ELSE p_key END
WHERE p_key IN ('a', 'b');
```

- 检查两个表数据是否一致

> Case函数不同于DECODE函数。在Case函数中，可以使用BETWEEN,LIKE,IS NULL,IN,EXISTS等等。比如说使用IN,EXISTS，可以进行子查询，从而 实现更多的功能。

```sql
--使用IN的时候
SELECT keyCol,
CASE WHEN keyCol IN ( SELECT keyCol FROM tbl_B )  THEN 'Matched'
ELSE 'Unmatched' END Label
FROM tbl_A;

--使用EXISTS的时候
SELECT keyCol,
CASE WHEN EXISTS ( SELECT * FROM tbl_B  WHERE tbl_A.keyCol = tbl_B.keyCol )  THEN 'Matched'  ELSE 'Unmatched' END Label
FROM tbl_A;
```

- 在Case函数中使用合计函数

```sql
/* Studentclass
+------+----------+--------------+-----------------+
|std_id| class_id |  class_name  |  main_class_flg |
+------+----------+--------------+-----------------+
| 100  |    1     |     经济学    |        Y        |
| 100  |    2     |     历史学    |        N        |
| 200  |    2     |     历史学    |        N        |
| 200  |    3     |     考古学    |        Y        |
| 200  |    4     |     计算机    |        N        |
| 300  |    4     |     计算机    |        N        |
| 400  |    5     |      化学     |        N        |
| 500  |    6     |      数学     |        N        |
+------+----------+---------------+----------------+
*/

--条件1：只选择了一门课程的学生, 返回那门课程的ID
SELECT std_id, MAX(class_id) AS main_class  FROM Studentclass  GROUP BY std_id  HAVING COUNT(*) = 1;

--条件2：选择多门课程的学生, 返回所选的主课程ID
SELECT std_id, class_id AS main_class  FROM Studentclass  WHERE main_class_flg = 'Y';

--使用Case函数,满足以上两个条件
SELECT  std_id, 
CASE
WHEN COUNT(*) = 1                   THEN MAX(class_id)
ELSE
MAX(CASE WHEN main_class_flg = 'Y'  THEN class_id  ELSE NULL END)
END AS main_class
FROM Studentclass  GROUP BY std_id;
```

- select case when

> select 与 case结合使用最大的好处有两点，一是在显示查询结果时可以灵活的组织格式，二是有效避免了多次对同一个表或几个表的访问。

```sql
/* 例如表 students(id, name ,birthday, sex, grade)，要求按每个年级统计男生和女生的数量各是多少，统计结果的表头为，年级，男生数量，女生数量。如果不用select case when，为了将男女数量并列显示，统计起来非常麻烦，先确定年级信息，再根据年级取男生数和女生数，而且很容易出错。*/

SELECT grade, COUNT (CASE WHEN sex = 1 THEN 1
                            ELSE NULL
                        END) 男生数,
               COUNT (CASE WHEN sex = 2 THEN 1
                            ELSE NULL
                       END) 女生数
FROM students

GROUP BY grade;
```

# Mysql数据库

## 1. mysql 常用数据类型

## 2. mysql数据库引擎

## 3. mysql的索引类型

## 4. mysql 几种锁的区别

## 5. mysql事务原理、特性、事务并发控制

## 6. mysql里的in、not in、like走不走索引

## 7. mysql查询优化

## 8. mysql的主从复制

## 9.左连接右连接的区别

# Redis数据库

## 1. redis的原理

## 2. 持久化机制

## 3. redis 和 memcached 的主要区别

## 4. Redis 高可用

## 5. Redis 高并发

## 6. redis的数据类型

## 7. redis的AOF太大如何优化

## 8. redis集群，如何扩展

# MongoDB数据库

## 1. 如何启动

# Elasticsearch数据库

## 1. 索引如何存储

## 2. 介绍下Elastisearch原理和用途

## 3. 分布式实时日志使用ELK

# Hive数据库

# Hbase数据库

# Hadoop生态