---
layout: post
title: 数据库知识点总结归纳
date: 2020-05-08 23:05:08
updated: 2020-05-14 01:45:02
tags: 
  - 数据库
  - Mysql
  - Redis
categories: 数据库

---

> 本文主要对数据库基础知识进行梳理、回顾，把一些需要记住的概念原理，和容易混淆，晦涩的知识点进行归纳。

<!-- more -->

<div style='display: none'>

<!-- TOC -->

- [数据库常识](#数据库常识)
    - [1. 什么是索引](#1-什么是索引)
    - [2. 事务的特性](#2-事务的特性)
    - [3. 存储过程](#3-存储过程)
    - [4. 数据库怎么优化查询效率](#4-数据库怎么优化查询效率)
    - [5. 数据库优化方案](#5-数据库优化方案)
    - [6. 什么是悲观锁](#6-什么是悲观锁)
    - [7. 什么是乐观锁](#7-什么是乐观锁)
    - [8. 什么是缓存穿透](#8-什么是缓存穿透)
    - [9. 什么是缓存击穿](#9-什么是缓存击穿)
    - [10. 什么是缓存雪崩](#10-什么是缓存雪崩)
    - [11. SQL查询基础](#11-sql查询基础)
    - [12. 排序](#12-排序)
    - [13. 聚合函数](#13-聚合函数)
    - [14. 分组](#14-分组)
    - [15. 关联查询](#15-关联查询)
    - [16. LIMIT的用法](#16-limit的用法)
    - [17. case when](#17-case-when)
- [Mysql数据库](#mysql数据库)
    - [1. mysql 常用数据类型](#1-mysql-常用数据类型)
    - [2. mysql数据库引擎](#2-mysql数据库引擎)
    - [3. mysql的索引类型](#3-mysql的索引类型)
    - [4. Mysql 几种锁的区别](#4-mysql-几种锁的区别)
    - [5. mysql事务原理、特性、事务并发控制](#5-mysql事务原理特性事务并发控制)
- [Redis数据库](#redis数据库)
    - [1. redis的原理](#1-redis的原理)
    - [2. 持久化机制](#2-持久化机制)
    - [3. redis 和 memcached 的主要区别](#3-redis-和-memcached-的主要区别)
    - [4. Redis 高可用](#4-redis-高可用)
    - [5. Redis 高并发](#5-redis-高并发)
- [MongoDB数据库](#mongodb数据库)
- [Hive数据库](#hive数据库)
- [Hbase数据库](#hbase数据库)
- [Hadoop生态](#hadoop生态)

<!-- /TOC -->

</div>

# 数据库常识

## 1. 什么是索引

## 2. 事务的特性

- 原子性(Atomicity)

> 事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。

- 一致性(Consistency)

> 几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。

- 隔离性(Isolation)

> 事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。

- 持久性(Durability)

> 对于任意已交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现异常。

## 3. 存储过程

## 4. 数据库怎么优化查询效率

## 5. 数据库优化方案

## 6. 什么是悲观锁

## 7. 什么是乐观锁

## 8. 什么是缓存穿透

## 9. 什么是缓存击穿

## 10. 什么是缓存雪崩

## 11. SQL查询基础

**[SQL基础知识](https://www.runoob.com/sql/sql-tutorial.html)**

- select语句

> 格式：select 字段 from 表名； # 全部字段可以用 *

- where 用于限制查询的结果

> 格式：where 字段='xxx';  # 查询条件> < >= <= = !=

- 与(AND)或(OR)

- 在(IN)不在(NOT IN)

- 空(NULL)非空(NOT NULL)

- 全部(ALL) 任一(ANY)

- 在[a,b]之间

> 格式：between a and b

- 排重DISTINCT

> 格式：select DISTINCT 字段 from 表名；

## 12. 排序

- ORDER BY语句

> 格式：select 字段 from 表名 where 条件 ORDER BY 字段；

- 升序(ASC)与降序(DESC)

> 格式：select 字段 from 表名 where 条件 ORDER BY 字段 ASC;  
> 格式：select 字段 from 表名 where 条件 ORDER BY 字段 DESC;  

- 多项排序

> 格式：select 字段 from 表名 where 条件 ORDER BY 字段 ASC|DESC，字段ASC|DESC;

## 13. 聚合函数

> 把 select 语句的查询结果汇聚成一个结果，这样的函数叫聚合函数。

- 最大值(MAX)

- 最小值(MIN)

- 平均值(SVG)

- 求和(SUM)

- 统计数量(COUNT)

## 14. 分组

- GROUP BY

> 格式：select 组函数 from 表 where 条件 group by 字段;

- HAVING 组判断条件，它的真假决定一组数据是否返回

> 格式：select 组函数 from 表 where 条件 group by 字段 having 组判断条件;

## 15. 关联查询

- JOIN：如果表中有至少一个匹配，则返回行  

> 格式：select * from a join b on a.id=b.id;

- 内连接(INNER JOIN)：只返回两个表中联结字段相等的行

> 格式：select * from a inner join b on a.id=b.id;  # 其中inner可以省略，等同于JOIN的用法

- 左外连接(LEFT JOIN 或 LEFT OUTER JOIN)：即使右表中没有匹配，也从左表返回所有的行

> 格式：select * from a left outer join b on a.id=b.aid;  # 其中outer可忽略

- 右外连接(RIGHT JOIN 或 RIGHT OUTER JOIN)：即使左表中没有匹配，也从右表返回所有的行

> 格式：select * from a right outer join b on a.id=b.aid;  # 其中outer可忽略

- 全连接(FULL JOIN 或 FULL OUTER JOIN): 只要其中一个表中存在匹配，就返回行。相当于左外连接+右外链接，注意mysql不支持全连接

> 格式：select * from a full outer join b on a.id=b.id。# 其中outer可忽略

- 自连接：自连接意思是把自身表当成另外一张表看待，互相关联查询，连接方式可以使用以上的内外连接，这种连接方式可以解决很多奇怪的问题。

> 格式：SELECT ab.* from a ab,a ac where ab.id>ac.id

## 16. LIMIT的用法

> 格式：select * from student limit 10;  # 查询前10条数据，显示1-10条数据

> 格式：select * from student limit 1,10;  # 查询从第2行开始，累加10条id记录，共显示id为2....11

> 格式：select * from student limit 5,10;  # 查询从第6行开始向前加10条数据，共显示id为6,7....15  

> 格式：select * from student limit i,n;  # i: 为查询结果的索引值(默认从0开始),当i=0时可省略i; n: 为查询结果返回的数量

## 17. case when

**[CASE WHEN 及 SELECT CASE WHEN的用法](https://www.cnblogs.com/aipan/p/7770611.html)**
**[SQL Case when 的使用方法](https://www.cnblogs.com/cx-zyq/archive/2013/05/16/3082295.html)**

- 简单Case函数

```sql
CASE sex
WHEN '1' THEN '男'
WHEN '2' THEN '女'
ELSE '其他' END
```

- Case搜索函数

```sql
CASE WHEN sex = '1' THEN '男'
WHEN sex = '2' THEN '女'
ELSE '其他' END
```
> 两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。还有一个需要注意的问题，Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。

**实例分析：**

(1). 已知数据按照另外一种方式进行分组，分析

```sql
/*根据这个国家人口数据，统计亚洲和北美洲的人口数量*/
SELECT  SUM(population),
CASE country  WHEN '中国' THEN '亚洲'
  WHEN '印度' THEN '亚洲'
  WHEN '日本' THEN '亚洲'
  WHEN '美国' THEN '北美洲'
  WHEN '加拿大'  THEN '北美洲'
  WHEN '墨西哥'  THEN '北美洲'
ELSE '其他' END
FROM    Table_A
GROUP BY
CASE country 
WHEN '中国' THEN '亚洲'
WHEN '印度' THEN '亚洲'
WHEN '日本' THEN '亚洲'
WHEN '美国' THEN '北美洲'
WHEN '加拿大'   THEN '北美洲'
WHEN '墨西哥'   THEN '北美洲'
ELSE '其他' END;

```

```sql
/*判断工资的等级，并统计每一等级的人数*/
SELECT
CASE WHEN salary <= 500 THEN '1'
WHEN salary > 500 AND salary <= 600  THEN '2'
WHEN salary > 600 AND salary <= 800  THEN '3'
WHEN salary > 800 AND salary <= 1000 THEN '4'
ELSE NULL END salary_class, -- 别名命名
COUNT(*)  FROM    Table_A
GROUP BY
CASE WHEN salary <= 500 THEN '1'
WHEN salary > 500 AND salary <= 600  THEN '2'
WHEN salary > 600 AND salary <= 800  THEN '3'
WHEN salary > 800 AND salary <= 1000 THEN '4'
ELSE NULL END;
```

(2). 用一个SQL语句完成不同条件的分组

```sql
/*按照国家和性别进行分组*/
SELECT country, 
SUM( CASE WHEN sex = '1' THEN  population ELSE 0 END),  --男性人口
SUM( CASE WHEN sex = '2' THEN  population ELSE 0 END)   --女性人口
FROM  Table_A  GROUP BY country;
```

(3). 在Check中使用Case函数

```sql
/*公司A，这个公司有个规定，女职员的工资必须高于1000块*/
CONSTRAINT check_salary CHECK
( CASE WHEN sex = '2'
THEN CASE WHEN salary > 1000
THEN 1 ELSE 0 END
ELSE 1 END = 1 )
```

(4). 根据条件有选择的UPDATE

```sql
/* 1.工资5000以上的职员，工资减少10% */
UPDATE Personnel  SET salary = salary * 0.9  WHERE salary >= 5000;

/* 2.工资在2000到4600之间的职员，工资增加15% */
UPDATE Personnel  SET salary = salary * 1.15 WHERE salary >= 2000 AND salary < 4600;

/* 3.如果满足条件1和条件2，顺序执行则会出现问题。
假设有个人工资5000块。首先，按照条件1，工资减少10%，变成工资4500。
接下来运行第二个SQL时候，因为这个人的工资是4500在2000到4600的范围之内，需增加15%，
最后这个人的工资结果是5175,不但没有减少，反而增加了。
如果要是反过来执行，那么工资4600的人相反会变成减少工资。 
这里用到case when 进行不同条件的更新*/
UPDATE Personnel
SET salary =
CASE WHEN salary >= 5000  　                THEN salary * 0.9
     WHEN salary >= 2000 AND salary < 4600  THEN salary * 1.15
ELSE salary END;  -- 这行else必须写，不写会导致不符合这两个条件的工资会变成NULL
```

```sql
/* 把主键a和b相互交换 */
UPDATE SomeTable
SET p_key = CASE WHEN p_key = 'a'  THEN 'b'
WHEN p_key = 'b'  THEN 'a'  ELSE p_key END
WHERE p_key IN ('a', 'b');
```

- 检查两个表数据是否一致

> Case函数不同于DECODE函数。在Case函数中，可以使用BETWEEN,LIKE,IS NULL,IN,EXISTS等等。比如说使用IN,EXISTS，可以进行子查询，从而 实现更多的功能。

```sql
--使用IN的时候
SELECT keyCol,
CASE WHEN keyCol IN ( SELECT keyCol FROM tbl_B )  THEN 'Matched'
ELSE 'Unmatched' END Label
FROM tbl_A;

--使用EXISTS的时候
SELECT keyCol,
CASE WHEN EXISTS ( SELECT * FROM tbl_B  WHERE tbl_A.keyCol = tbl_B.keyCol )  THEN 'Matched'  ELSE 'Unmatched' END Label
FROM tbl_A;
```

- 在Case函数中使用合计函数

```sql
/* Studentclass
+------+----------+--------------+-----------------+
|std_id| class_id |  class_name  |  main_class_flg |
+------+----------+--------------+-----------------+
| 100  |    1     |     经济学    |        Y        |
| 100  |    2     |     历史学    |        N        |
| 200  |    2     |     历史学    |        N        |
| 200  |    3     |     考古学    |        Y        |
| 200  |    4     |     计算机    |        N        |
| 300  |    4     |     计算机    |        N        |
| 400  |    5     |      化学     |        N        |
| 500  |    6     |      数学     |        N        |
+------+----------+---------------+----------------+
*/

--条件1：只选择了一门课程的学生, 返回那门课程的ID
SELECT std_id, MAX(class_id) AS main_class  FROM Studentclass  GROUP BY std_id  HAVING COUNT(*) = 1;

--条件2：选择多门课程的学生, 返回所选的主课程ID
SELECT std_id, class_id AS main_class  FROM Studentclass  WHERE main_class_flg = 'Y';

--使用Case函数,满足以上两个条件
SELECT  std_id, 
CASE
WHEN COUNT(*) = 1                   THEN MAX(class_id)
ELSE
MAX(CASE WHEN main_class_flg = 'Y'  THEN class_id  ELSE NULL END)
END AS main_class
FROM Studentclass  GROUP BY std_id;
```

- select case when

> select 与 case结合使用最大的好处有两点，一是在显示查询结果时可以灵活的组织格式，二是有效避免了多次对同一个表或几个表的访问。

```sql
/* 例如表 students(id, name ,birthday, sex, grade)，要求按每个年级统计男生和女生的数量各是多少，统计结果的表头为，年级，男生数量，女生数量。如果不用select case when，为了将男女数量并列显示，统计起来非常麻烦，先确定年级信息，再根据年级取男生数和女生数，而且很容易出错。*/

SELECT grade, COUNT (CASE WHEN sex = 1 THEN 1
                            ELSE NULL
                        END) 男生数,
               COUNT (CASE WHEN sex = 2 THEN 1
                            ELSE NULL
                       END) 女生数
FROM students

GROUP BY grade;
```

# Mysql数据库

## 1. mysql 常用数据类型

## 2. mysql数据库引擎

## 3. mysql的索引类型

## 4. Mysql 几种锁的区别

## 5. mysql事务原理、特性、事务并发控制

# Redis数据库

## 1. redis的原理

## 2. 持久化机制

## 3. redis 和 memcached 的主要区别

## 4. Redis 高可用

## 5. Redis 高并发

# MongoDB数据库

# Hive数据库

# Hbase数据库

# Hadoop生态