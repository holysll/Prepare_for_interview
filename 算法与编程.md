---
layout: post
title: 算法编程知识点总结归纳
date: 2020-05-08 23:05:08
updated: 2020-05-14 01:36:55
tags: 
  - 算法
categories: 算法编程

---

> 本文主要对算法编程基础知识进行梳理、回顾，以及一些常见的算法掌握。

<!-- more -->

<div style='display: none'>

<!-- TOC -->

- [算法编程](#算法编程)
    - [1. 反转链表](#1-反转链表)
    - [2. DFS](#2-dfs)
    - [3. BFS](#3-bfs)
    - [4. 冒泡排序](#4-冒泡排序)
    - [5. 快排](#5-快排)
    - [6. 堆排序](#6-堆排序)
    - [7. 二叉树](#7-二叉树)
        - [(1) 二叉树的最低深度路径打印](#1-二叉树的最低深度路径打印)
        - [(2) 二叉树的后续遍历，非递归实现](#2-二叉树的后续遍历非递归实现)
        - [(3) 完全二叉树](#3-完全二叉树)
    - [8. 二分查找](#8-二分查找)
    - [9. 求最大树深](#9-求最大树深)
    - [10. 动态规划问题](#10-动态规划问题)
    - [11. 01背包问题](#11-01背包问题)
    - [12. 两个栈实现一个队列](#12-两个栈实现一个队列)
    - [13. 二叉树的直径](#13-二叉树的直径)
    - [14. 全排列](#14-全排列)
    - [15. 最大公约数](#15-最大公约数)
    - [16. 最小公倍数](#16-最小公倍数)
    - [17. 求素数](#17-求素数)
    - [18. 求质数](#18-求质数)
    - [19. 查并集](#19-查并集)
    - [20. 排序算法复杂度中nlgn中的lgn是怎么来的](#20-排序算法复杂度中nlgn中的lgn是怎么来的)
    - [21. 字符串中最长不重复子串](#21-字符串中最长不重复子串)
    - [22. 两个字符串，求其最长子串](#22-两个字符串求其最长子串)

<!-- /TOC -->

</div>

# 算法编程

## 1. 反转链表

## 2. DFS

## 3. BFS

## 4. 冒泡排序

## 5. 快排

## 6. 堆排序

## 7. 二叉树

### (1) 二叉树的最低深度路径打印

### (2) 二叉树的后续遍历，非递归实现

### (3) 完全二叉树

## 8. 二分查找

## 9. 求最大树深

## 10. 动态规划问题

## 11. 01背包问题

## 12. 两个栈实现一个队列

## 13. 二叉树的直径

## 14. 全排列

- itertools内置permutations方法实现

```python
from itertools import permutations

def func():
    while True:
        try:
            n = int(input().strip())
            s = [str(i + 1) for i in range(n)]
            res = list(permutations(s))
            for i in res:
                print(" ".join(i))
            print(len(res))
        except:
            break

if __name__ == "__main__":
    func()
```

- 递归实现

具体详细的思路参考：

**[递归实现全排列（回溯思想）](https://blog.csdn.net/weixin_39910711/article/details/100692318)**

```python
def permutations(s, begin, end):
    global count
    if begin == end:
        print(" ".join(s))
        count += 1
    else:
        for i in range(begin, end):
            s[i], s[begin] = s[begin], s[i]
            permutations(s, begin + 1, end)
            s[i], s[begin] = s[begin], s[i]


if __name__ == "__main__":
    s = [str(i + 1) for i in range(int(input().strip()))]
    count = 0
    permutations(s, 0, len(s))
    print(count)
```

- DFS实现

**[深度优先搜索（DFS）实现全排列](https://blog.csdn.net/weixin_39910711/article/details/100692318)**

```python
def permutations(s, position, visit, num):
    if position == len(s):
        print(" ".join(num))
        return

    else:
        for index in range(len(s)):
            if visit[index] == True:
                num[position] = s[index]
                visit[index] = False
                permutations(s, position + 1, visit, num)
                visit[index] = True


if __name__ == "__main__":
    n = int(input().strip())
    s = [str(i + 1) for i in range(n)]
    visit = [True] * n
    num = ["" for i in range(n)]
    permutations(s, 0, visit, num)
```

## 15. 最大公约数

## 16. 最小公倍数

**[最小公倍数](https://blog.csdn.net/weixin_41980474/article/details/80139275)**

## 17. 求素数

## 18. 求质数

## 19. 查并集

**[并查集(Union-Find)算法详解](https://blog.csdn.net/guoziqing506/article/details/78752557)**
**[并查集详解](https://blog.csdn.net/qq_41593380/article/details/81146850)**
**[并查集(Union-Find)算法介绍](https://blog.csdn.net/dm_vincent/article/details/7655764)**

## 20. 排序算法复杂度中nlgn中的lgn是怎么来的

## 21. 字符串中最长不重复子串

## 22. 两个字符串，求其最长子串
