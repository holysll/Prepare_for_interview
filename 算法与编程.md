---
layout: post
title: 算法编程知识点总结归纳
date: 2020-05-08 23:05:08
updated: 2020-05-14 01:36:55
tags: 
  - 算法
categories: 算法编程

---

> 本文主要对算法编程基础知识进行梳理、回顾，以及一些常见的算法掌握。

<!-- more -->

<div style='display: none'>

<!-- TOC -->

- [算法编程](#算法编程)
    - [1. 反转链表](#1-反转链表)
    - [2. DFS](#2-dfs)
    - [3. BFS](#3-bfs)
    - [4. 冒泡排序](#4-冒泡排序)
    - [5. 快排](#5-快排)
    - [6. 堆排序](#6-堆排序)
    - [7. 二叉树](#7-二叉树)
        - [(1) 二叉树的最低深度路径打印](#1-二叉树的最低深度路径打印)
        - [(2) 二叉树的后续遍历，非递归实现](#2-二叉树的后续遍历非递归实现)
        - [(3) 完全二叉树](#3-完全二叉树)
    - [8. 二分查找](#8-二分查找)
    - [9. 求最大树深](#9-求最大树深)
    - [10. 动态规划问题](#10-动态规划问题)
    - [11. 01背包问题](#11-01背包问题)
    - [12. 两个栈实现一个队列](#12-两个栈实现一个队列)
    - [13. 二叉树的直径](#13-二叉树的直径)
    - [14. 全排列](#14-全排列)
    - [15. 最大公约数](#15-最大公约数)
    - [16. 最小公倍数](#16-最小公倍数)
    - [17. 求素数](#17-求素数)
    - [18. 求质数](#18-求质数)
    - [19. 查并集](#19-查并集)
    - [20. 排序算法复杂度中nlgn中的lgn是怎么来的](#20-排序算法复杂度中nlgn中的lgn是怎么来的)
    - [21. 字符串中最长不重复子串](#21-字符串中最长不重复子串)
    - [22. 两个字符串，求其最长子串](#22-两个字符串求其最长子串)
    - [23. 按序打印(多线程)](#23-按序打印多线程)
        - [（1）利用队列](#1利用队列)

<!-- /TOC -->

</div>

# 算法编程

## 1. 反转链表

```python
"""
题目：
反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
"""

# Python packages

# 双指针迭代
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 申请两个指针，pre 和 cur，pre指向None
        pre = None
        cur = head
        # 遍历链表
        while cur:
            # 记录当前节点的下一个节点
            temp = cur.next
            # 然后将当前节点指向pre
            cur.next = pre
            # pre 和 cur 节点都往后移一位
            pre = cur
            cur = temp
        return pre

def createList():
    head = ListNode(1)
    cur = head
    for i in range(1,6):
        cur.next = ListNode(i)
        cur = cur.next
    return head

def printList(head):
    cur = head
    while cur:
        print(cur.val, '-->', end='')
        cur = cur.next

    print('NULL')


if __name__ == '__main__':
    head = createList()
    solution = Solution()
    res = solution.reverseList(head)
    printList(res)


# 递归解法
class Solution(object):
    def reverseList(self, head)：
        """
        :type head: ListNode
        :rtype: ListNode
        """
        # 递归终止条件是当前为空，或者下一个节点为空
        if (head == None or head.next == None)：
            return head
        # 这里的cur就是最后一个点
        cur = self.reverseList(head.next)
        # 如果链表是 1->2->3->4->5，那么此时的cur就是5，而head是4，head的下一个是5，下下一个是空，所以head.next.next 就是5 -> 4
        head.next.next = head
        # 防止链表循环，需要将head.next设置为空
        head.next = None
        # 每层递归函数都返回cur，也就是最后一个节点
        return cur
```

## 2. DFS

## 3. BFS

## 4. 冒泡排序

## 5. 快排

## 6. 堆排序

## 7. 二叉树

### (1) 二叉树的最低深度路径打印

### (2) 二叉树的后续遍历，非递归实现

### (3) 完全二叉树

## 8. 二分查找

## 9. 求最大树深

## 10. 动态规划问题

## 11. 01背包问题

## 12. 两个栈实现一个队列

## 13. 二叉树的直径

## 14. 全排列

- itertools内置permutations方法实现

```python
from itertools import permutations

def func():
    while True:
        try:
            n = int(input().strip())
            s = [str(i + 1) for i in range(n)]
            res = list(permutations(s))
            for i in res:
                print(" ".join(i))
            print(len(res))
        except:
            break

if __name__ == "__main__":
    func()
```

- 递归实现

具体详细的思路参考：

**[递归实现全排列（回溯思想）](https://blog.csdn.net/weixin_39910711/article/details/100692318)**

```python
def permutations(s, begin, end):
    global count
    if begin == end:
        print(" ".join(s))
        count += 1
    else:
        for i in range(begin, end):
            s[i], s[begin] = s[begin], s[i]
            permutations(s, begin + 1, end)
            s[i], s[begin] = s[begin], s[i]


if __name__ == "__main__":
    s = [str(i + 1) for i in range(int(input().strip()))]
    count = 0
    permutations(s, 0, len(s))
    print(count)
```

- DFS实现

**[深度优先搜索（DFS）实现全排列](https://blog.csdn.net/weixin_39910711/article/details/100692318)**

```python
def permutations(s, position, visit, num):
    if position == len(s):
        print(" ".join(num))
        return

    else:
        for index in range(len(s)):
            if visit[index] == True:
                num[position] = s[index]
                visit[index] = False
                permutations(s, position + 1, visit, num)
                visit[index] = True


if __name__ == "__main__":
    n = int(input().strip())
    s = [str(i + 1) for i in range(n)]
    visit = [True] * n
    num = ["" for i in range(n)]
    permutations(s, 0, visit, num)
```

## 15. 最大公约数

## 16. 最小公倍数

**[最小公倍数](https://blog.csdn.net/weixin_41980474/article/details/80139275)**

## 17. 求素数

## 18. 求质数

## 19. 查并集

**[并查集(Union-Find)算法详解](https://blog.csdn.net/guoziqing506/article/details/78752557)**
**[并查集详解](https://blog.csdn.net/qq_41593380/article/details/81146850)**
**[并查集(Union-Find)算法介绍](https://blog.csdn.net/dm_vincent/article/details/7655764)**

## 20. 排序算法复杂度中nlgn中的lgn是怎么来的

## 21. 字符串中最长不重复子串

## 22. 两个字符串，求其最长子串

## 23. 按序打印(多线程)

### （1）利用队列

```python
from multiprocessing import Queue
class Foo(object):
    def __init__(self):
        self.q2 = Queue()
        self.q3 = Queue()


    def first(self, printFirst):
        """
        :type printFirst: method
        :rtype: void
        """

        # printFirst() outputs "first". Do not change or remove this line.
        printFirst()
        self.q2.put("")


    def second(self, printSecond):
        """
        :type printSecond: method
        :rtype: void
        """
        self.q2.get()
        # printSecond() outputs "second". Do not change or remove this line.
        printSecond()
        self.q3.put("")


    def third(self, printThird):
        """
        :type printThird: method
        :rtype: void
        """
        self.q3.get()
        # printThird() outputs "third". Do not change or remove this line.
        printThird()
```
